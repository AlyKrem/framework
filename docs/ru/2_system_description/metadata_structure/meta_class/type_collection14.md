### Предыдущая страница: [Ссылка](/docs/ru/2_system_description/metadata_structure/meta_class/type_reference13.md)
# Коллекция
## Общее описание

**Коллекция** - тип данных, который хранит в себе ссылки на другие объекты. Данные объекты могут быть объектами исходного класса, если коллекция ссылается на класс, в котором определяется данная коллекция. Например, класс "Монитор" может содержать ссылку "С данной элетронникой также покупают" на класс "Электроника". Класс "Электроника" является родительским классом по отношению к классу "Монитор", поэтому ссылка "С данной элетронникой также покупают" может содержать объекты класса "Монитор". Каждая ссылка содержит значение идентификатора объекта. Идентификаторы объектов определяются ключем в мете класса-коллекции, в данном случае в классе "Электроника". Переопределять ключ в классе "Монитор" нельзя.  

Разделяются ссылки через запятую. Все значения из последовательности ссылок и запятых хранятся строкой в базе данны.


### Способы задания коллекций с точки зрения используемых полей атрибутивной части меты классов:
1. `один-ко-многим` - означает наличие контейнера и вложенного объекта с ссылкой на контейнер. В контейнере необходимо указать коллекцию, а у нее указать ссылочный атрибут вложенного объекта по которому формируется связь. __См. Обратные ссылки в контексте коллекций.__ 
2. `многие-ко-многим` - необходимо определить коллекцию без ссылок, и указать класс вложенных элементов - связи создаются при помещении в коллекцию и хранятся как отдельные сущности в БД. __См. Коллекции.__
3. `обратная коллекция` - если коллекция многие ко многим задается на основании коллекции в другом объекте. то другая сторона связи задается через *backColl*. __См. Обратные коллекции.__


## Атрибут коллекция в формате JSON 

### Пример

```
{
      "orderNumber": 50,
      "name": "table",
      "caption": "Таблица",
      "type": 14,
      "size": null,
      "decimals": 0,
      "allowedFileTypes": null,
      "maxFileCount": 0,
      "nullable": true,
      "readonly": false,
      "indexed": false,
      "unique": false,
      "autoassigned": false,
      "hint": null,
      "defaultValue": null,
      "refClass": "",
      "itemsClass": "collRefCatalog@develop-and-test",
      "backRef": "",
      "backColl": "",
      "binding": "",
      "semantic": null,
      "selConditions": [],
      "selSorting": [],
      "selectionProvider": null,
      "indexSearch": false,
      "eagerLoading": false,
      "formula": null
    }
```  


## Обратная ссылка в контексте коллекций

Обратная ссылка в контексте коллекций образуется следующим образом:
- Создается обычная коллекция с указанием ссылочного класса
- В ссылочном классе должен быть атрибут-ссылка, ссылающийся на исходный класс и имеющий свойство `unique` равным `false` . Значение в атрибут-ссылку присваивается сразу при создании связи с коллекцией, без необходимости сохранения формы
- В исходном классе в обычной коллекции заполняем свойство `"backRef"` - туда записывается код атрибута-ссылки из ссылочного класса

## Обратная ссылка в формате JSON 

### Пример

```
{
      "orderNumber": 30,
      "name": "coll",
      "caption": "Коллекция с обратной ссылкой",
      "type": 14,
      "size": null,
      "decimals": 0,
      "allowedFileTypes": null,
      "maxFileCount": 0,
      "nullable": true,
      "readonly": false,
      "indexed": false,
      "unique": false,
      "autoassigned": false,
      "hint": null,
      "defaultValue": null,
      "refClass": null,
      "itemsClass": "ref_backcoll_ref@develop-and-test",
      "backRef": "ref_backcoll_ref",
      "backColl": "",
      "binding": "",
      "semantic": "backcoll_data",
      "selConditions": [],
      "selSorting": [],
      "selectionProvider": null,
      "indexSearch": false,
      "eagerLoading": true,
      "formula": null
    }
```  


# Обратная коллекция

Пример коллекции выше преобразуется для обратной коллекции слудующим образом:

```
{
      "orderNumber": 30,
      "name": "backcoll",
      "caption": "Обратная коллекции",
      "type": 14,
      "size": null,
      "decimals": 0,
      "allowedFileTypes": null,
      "maxFileCount": 0,
      "nullable": true,
      "readonly": false,
      "indexed": false,
      "unique": false,
      "autoassigned": false,
      "hint": null,
      "defaultValue": null,
      "refClass": "",
      "itemsClass": "coll_backcoll_coll",
      "backRef": "",
      "backColl": "coll",
      "binding": "",
      "semantic": "backcoll_data",
      "selConditions": [],
      "selSorting": [],
      "selectionProvider": null,
      "indexSearch": false,
      "eagerLoading": true,
      "formula": null
    }
```


Обратите внимание на указание в свойстве `"backColl"`. Таким образом, реализуется связь многие-ко-многим без промежуточного класса. Не только атрибут "backcoll" с типом "Коллекция" может содержать несколько ссылок, но и объекты по ссылкам также могут содержать в своей коллекции "coll" несколько ссылок на объекты исходного класса.

### *Внимание*

- `"type": 14` - тип атрибута "Коллекция"
- `"backColl"` - название ссылочного атрибута типа коллеции, ссылающегося на исходный класс с коллекцией.
- `"itemsClass"` - название класса, объекты которого могут хранить свои идентификаторы в коллекции и, таким образом, формировать связь к объекту по идентификатору.
- `"backRef"` - атрибута-ссылка из ссылочного класса, указанного в `"itemsClass"`
- При указании класса-родителя есть возможность создавать объекты родительского и дочерних классов
- Коллекции вместе с объектом грузятся по семантике, заданной в мете класса-коллекции или атрибута-коллекции


## Схема обработки коллекций и формат хранения в БД
Для сохранения коллекции, необходимо передать в соответствующем ей атрибуте объекта массив действий вида:
```
"collection": [
  {"action": "put", "id": "1234"},
  {"action": "put", "id": "1235"},
  {"action": "put", "id": "1236"},
  {"action": "eject", "id": "1230"}
]
```
Порядок объектов должен соответствовать порядку выполнения соответствующих действий. Коды операций: `put` - добавление в коллекцию, `eject` - извлечение из коллекции. Алгоритм для создания и редактирования одинаков. Действия с коллекциями выполняются после создания или сохранения контейнера.

Логика работы коллекций на форме создания и редактирования принципиально разная: 
* На форме создания взаимодействие с сервером требуется лишь для получения и отображения в таблице выбранного/созданного объекта коллекции
* На форме редактирования реализована возможность получения ответа сервера при необходимости, и изменение параметров выборки при запросе, в зависимости от выполненных действий над коллекцией.



### Следующая страница: [Пользовательский тип](/docs/ru/2_system_description/metadata_structure/meta_class/type_user17.md)
--------------------------------------------------------------------------  


 #### [Licence](/LICENCE.md) &ensp;  [Contact us](https://iondv.com) &ensp;  [English](/docs/en/2_system_description/metadata_structure/meta_class/type_collection14.md)   &ensp; [FAQs](/faqs.md)          



--------------------------------------------------------------------------  

Copyright (c) 2018 **LLC "ION DV"**.
All rights reserved. 