# Вычислимые поля (описана реализация для реестра)

Реализована единая спецификация выражений, как для вычисляемых выражений, так и для условий отбора и расчетов в агрегации.

Механизм для формирования формул, которые вычисляются при открытии формы. При закрытии они сохраняются и их можно использовать, например в кликвьюв, или для других формул, или ссылочных полей. Может быть в семантике. 

Чтобы по полю пошло вычисление, нужно чтобы у него было не пустое значение в свойстве **formula**

# Модель записи формулы через объект

Общая модель формул:

* операнды
* слова начинающиеся с $ - сюда подставляются значения поля, если есть операнд разыменования (операция переход по ссылке) `.` - то значит из связанного объекта, пример $person.user
* слова начинающиеся с $$ - поля начинающиеся с $ - т.к. формуле передается контекст - в общем случае объект соответствующий спецификации, как правило передается объект с атрибутами $uid, $context и свойствами (properties) из профиля ($employee, $organization, ...). В $context пишется item. Если атрибут не находится в корне контекста, он рекурсивно ищется в $context. все это с учетом разыменования.
* остальное определяется как обычные строки

#### Пример применения формулы:

```
{
      "orderNumber": 5,
      "name": "addressString",
      "caption": "",
      "type": 0,
      "size": null,
      "decimals": 0,
      "allowedFileTypes": null,
      "maxFileCount": 0,
      "nullable": true,
      "readonly": false,
      "indexed": true,
      "unique": false,
      "autoassigned": false,
      "hint": null,
      "defaultValue": null,
      "refClass": "",
      "itemsClass": "",
      "backRef": "",
      "backColl": "",
      "binding": "",
      "semantic": null,
      "selConditions": [],
      "selSorting": [],
      "selectionProvider": null,
      "indexSearch": false,
      "eagerLoading": false,
      "formula": {
        "concat": [
          {
            "if": [
              "$zipCode",
              {
                "concat": [
                  "$zipCode"
                ]
              },
              ""
            ]
          },
          " ",
          {
            "if": [
              "$subjectFederation",
              "$subjectFederation",
              ""
            ]
          },
          {
            "if": [
              "$federationBorough",
              {
                "concat": [
                  ", ",
                  "$federationBorough"
                ]
              },
              ""
            ]
          },
          {
            "if": [
              {
                "and": [
                  {
                    "ne": [
                      "$subjectFederation",
                      "Санкт-Петербург г"
                    ]
                  },
                  {
                    "ne": [
                      "$subjectFederation",
                      "Москва г"
                    ]
                  }
                ]
              },
              {
                "concat": [
                  ", ",
                  "$town"
                ]
              },
              ""
            ]
          },
          {
            "if": [
              "$street",
              {
                "concat": [
                  ", ",
                  "$street"
                ]
              },
              ""
            ]
          },
          {
            "if": [
              "$houseNumber",
              {
                "concat": [
                  ", Дом ",
                  "$houseNumber"
                ]
              },
              ""
            ]
          },
          {
            "if": [
              "$flatNumber",
              {
                "concat": [
                  ", Квартира (офис) ",
                  "$flatNumber"
                ]
              },
              ""
            ]
          }
        ]
      }
    },

```
Результат: _вывод адреса с пробелами и запятыми между значениями атрибутов_

Пример формулы есть в ДнТ в соответствующем классе (calcAttr)
Поддерживаются функции:

`eq` - равно

`ne` - не равно

`lt` - меньше

`gt` - больше

`lte` - меньше либо равно

`gte` - больше, либо равно


`and` - и

`or` - или

`not` - не

`add` - арифметическое сложение

`sub` - арифметическое вычитание

`mul` - арифметическое умножение

`div` - арифметическое деление

`nempty` - не пусто

`empty` - пусто

`pad` - дополнение строки символами до нужной длины

`next` - 

`merge` - конкатенация атрибутов в коллекции

`size` - принимает в качестве аргумента атрибуты типа строка и коллекция. Для строк возвращает длину, для коллекций - количество элементов.

`element` - получение произвольного элемента из массива, индексирование с 0 ([массив значений], [индекс элемента: 0 - первый элемент, last - последний элемент])

`dateAdd` - добавление к дате (в нотации momentjs - [Дата], [добавляемый интервал (число)], [ед.изм (строка [d, m, y, h, min, s, ms)])

`dateDiff` - разница между датами (в нотации momentjs - [ед.изм], [Дата1], [Дата2])

`now` - текущая дата-время

`concat` - конкатенация строк
```
substring - получение подстроки ([Строка], [ с какого символа], [сколько символов])
```

`obj` - формирование объекта, нечетные аргументы - имена свойств, четные - значения

агрегация:

`max`, `min`, `avg`, `sum`, `count`

Все функции агрегации принимают следующие аргументы:

либо

```
[$Имя атрибута коллекции], [Имя агрегируемого атрибута], [функция фильтрации элементов коллекции]
```

либо

```
[Имя класса], [Имя агрегируемого атрибута], [Объект фильтра сформированный функцией obj соответствующий нотации фильтров mongodb]
```

`1` - указывает на уникальность объекта. То есть позволяет для функций агрегации производить подсчет только по уникальным объектам.

`\n` - перенос на другую строку

пример:

```
"formula": {
        "merge": [
          "$atr1",
          "atr2.name",
          null,
          1,
          "\n"
        ]
      },

```

#### Пример применения формулы (устаревшая форма записи):

```

    {
      "orderNumber": 40,
      "name": "kolStatOps",
      "caption": "Количество стационарных ОПС",
      "type": 6,
      "size": null,
      "decimals": 0,
      "allowedFileTypes": null,
      "maxFileCount": 0,
      "nullable": true,
      "readonly": false,
      "indexed": true,
      "unique": false,
      "autoassigned": false,
      "hint": null,
      "defaultValue": null,
      "refClass": "",
      "itemsClass": "",
      "backRef": "",
      "backColl": "",
      "binding": "",
      "semantic": null,
      "selConditions": [],
      "selSorting": [],
      "selectionProvider": null,
      "indexSearch": false,
      "eagerLoading": false,
      "formula": "count($raionObslu.oktmo_nasPunkta.svyaz.ops,&eq($gops, b), 1)",
      "cached": true
    }

```

Атрибут с типом "Ссылка" _$raionObslu_ ссылается на класс, в котором содержится список нас. пунктов в атрибуте типа "Коллекция" _oktmo_nasPunkta_. Заходим в каждый из нас пунктов и в ссылочном атрибуте _svyaz_ считаем количество объектов в коллекции _ops_ , у которых атрибут со списком выбора допустимых значений _gops_ равен значению значению _b_ - в итоге в строке выводится количество ОПС с типом _b_

# Пример вычисляемого поля
класс **khv-svyaz-info_municipalnieObrazovaniya**
```
{
                "orderNumber" : 15,
                "name" : "sumF",
                "caption" : "sumF",
                "type" : 0,
                "size" : 8,
                "decimals" : 0,
                "nullable" : false,
                "readonly" : true,
                "indexed" : false,
                "unique" : false,
                "autoassigned" : false,
                "defaultValue" : null,
                "refClass" : "",
                "itemsClass" : "",
                "backRef" : "",
                "backColl" : "",
                "binding" : "",
                "selConditions" : [],
                "selSorting" : [],
                "selectionProvider" : null,
                "indexSearch" : false,
                "eagerLoading" : false,
                "formula" : {
                    "operation" : "sum",
                    "operands" : "chislennost",
                    "path" : [ 
                        {
                            "property" : "oktmo_nasPunkta",
                            "selConditions" : [ 
                                {
                                    "property" : "chislennost_title",
                                    "operation" : 1,
                                    "value" : ""
                                }, 
                                {
                                    "property" : "chislennost",
                                    "operation" : 1,
                                    "value" : null
                                }
                            ],
                            "nestedConditions" : [ 
                                {
                                    "property" : "chislennost",
                                    "selConditions" : [ 
                                        {
                                            "property" : "period_title",
                                            "operation" : 9,
                                            "value" : ""
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            }
```

Получение численности населения у муниципального района за текущий (последний) период. 
# Разбор логики работы

имеем три главных свойства
1. "operation" 
2. "operands" 
3. "path"

## operation

| код| смысл|
| -------- | -------- |
|sum| суммирование (приведение к числу и сложение всех элементов получившегося списка. СПИСКА|
|count| кол-во элементов в получившемся СПИСКЕ|
|max| максимальное из списка|
|min| минимальное из списка|
|avg| среднее из списка|
|eval| eval выражения|

## operands
Название атрибута по которому будет выполняться операция, для всех кроме eval, для евала - формула вычисления 

## path 

Путь на основании которого в итоге получаем результат. На данный момент начинается с текущего класса и идет ниже по иерархии. имеет всего 3 свойства
1. "property" - атрибут по которому идет поиск
2. "selConditions" - фильтры накладываемые на выборку. Я считаю, что очень круто, что здесь именно **selConditions**, которые используются при фильтрации выборок. Это важно. можно сделать выборку в списке, сохранить ее в фильтре, а потом оттуда перенести в формулу. Если будут ( о они будут) развиваться дальше выборки, то формулы автоматом получат доп.возможности. 
Как например формулы НАХАЛЯВУ получили возможность получения макс/мин значения на основании операции 9\10. 
3. nestedConditions - по сути своей это рекурсия - т.е. дальнейший путь вглубь. 

вычисления идут, пока у объкта есть **nestedConditions**, как только они завершаются, то полученный результат передется в вычисление формулы

## Описание  логики для одной формулы
Сделали первую выборку, получили результат - посмотрели, есть ли у объекта **nestedConditions**, если есть. спустились на уровень вниз, и пока не дойдем до конца. Дошли до конца - передали результат на вычисление на основании операции  и атрибута записанных в начале.

## Описание логики для всех формул объекта

Открывается объект, на нем вызывается операция по получению результатов формул(асинхронно), когда результаты получены они записываются в атрибуты. Поэтому выглядит очень круто - быстро открывается окно, затем когда вычисления завершились, в атрибуты проставляются значения.
На входе имеем класс, объект.
1. Начинаем бежать по всем полям класса, если у них есть формула и они не евал, то вызываем вычисление (асинхронно), если формула и евал, - записываем атрибут.

2. дожидаемся выполнения всех не евал формул, записываем результат атрибут formulaRes для исходного объекта. Начинаем выполнения евал формул. 

## Автоприсвоение и получение значения атрибута в вычисляемом выражении

1. чтобы вычисляемое выражение не срабатывало при открытии формы создания, у атрибута надо выставить `autoassigned: true`. В этом случае выражения будут вычислены непосредственно перед сохранением объекта. Это актуально, если вы используете функцию `next` в вычислениях, потому что не всегда нужно извлекать очередное значение последовательности каждый раз при открытии формы создания.

2. значения по умолчанию рассчитываются ДО записи объекта в БД, т.е. на этапе их вычисления во всех простых автоприсваемых атрибутах еще ничего нет.

3. `next($id)` (если в `$id` будет значение) будет всегда возвращать 1, т.к. для КАЖДОГО объекта будет создаваться ОТДЕЛЬНАЯ последовательность, из которой будет браться всего ОДНО ПЕРВОЕ значение.

### Следующая страница []()
--------------------------------------------------------------------------  


 #### [Licence](/LICENCE.md) &ensp;  [Contact us](https://iondv.com) &ensp;  [English](/README.md)   &ensp; [FAQs](/faqs.md)          



--------------------------------------------------------------------------  

Copyright (c) 2018 **LLC "ION DV"**.
All rights reserved. 